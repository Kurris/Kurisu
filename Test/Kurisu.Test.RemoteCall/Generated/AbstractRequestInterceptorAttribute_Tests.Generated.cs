// <auto-generated />
using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using Kurisu.RemoteCall.Attributes;
using Kurisu.RemoteCall.Abstractions;
using Kurisu.RemoteCall.Default;
using Kurisu.RemoteCall.Proxy.Abstractions;
using Kurisu.RemoteCall.Utils;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Xunit;

namespace Kurisu.Test.RemoteCall.Generated
{
    public class AbstractRequestInterceptorAttribute_Tests
    {
        private class TestInterceptor : AbstractRequestInterceptorAttribute<string>
        {
            // expose protected HandleHttpContext via a public wrapper? not necessary; we will call BeforeRequestAsync which uses it
        }

        private class FakeInvocation : IProxyInvocation
        {
            public IServiceProvider ServiceProvider { get; set; }
            public Type InterfaceType { get; set; }
            public MethodInfo Method { get; set; }
            public ParameterInfo[] ParameterInfos { get; set; }
            public object[] ParameterValues { get; set; }
            public List<Kurisu.RemoteCall.ParameterValue> WrapParameterValues { get; set; }
            public object ReturnValue { get; set; }
            public RemoteClient RemoteClient { get; set; }
        }

        private class DummyValidator : IRemoteCallParameterValidator
        {
            public void Validate(object[] parameters)
            {
                if (parameters == null) throw new ArgumentNullException(nameof(parameters));
            }
        }

        private class DummyUrlResolver : IRemoteCallUrlResolver
        {
            public string ResolveUrl(string httpMethod, string baseUrl, string template, List<Kurisu.RemoteCall.ParameterValue> wrapParameterValues)
            {
                return baseUrl.TrimEnd('/') + "/" + template.TrimStart('/');
            }

            public string ResolveBaseUrl(string name) => name;
            public string ResolveTemplateUrl(string template, string clientBaseUrl, List<Kurisu.RemoteCall.ParameterValue> wrapParameterValues) => template;
            public string FixFromConfiguration(string url) => url;
        }

        private class DummyJsonSerializer : IJsonSerializer
        {
            public string Serialize(object obj) => System.Text.Json.JsonSerializer.Serialize(obj);
            public T Deserialize<T>(string text) 
            {
                if (typeof(T) == typeof(string))
                {
                    // when TResult is string, return raw response body
                    return (T)(object)text;
                }

                return System.Text.Json.JsonSerializer.Deserialize<T>(text);
            }
            public object Deserialize(string text, Type type) => System.Text.Json.JsonSerializer.Deserialize(text, type);
        }

        private class DummyCommonUtils : ICommonUtils
        {
            public bool IsReferenceType(Type type) => !type.IsValueType;
            public void ToObjDictionary(string name, object value, out Dictionary<string, object> dict)
            {
                dict = new Dictionary<string, object> { [name] = value };
            }

            public Dictionary<string, object> ToObjDictionary(string name, object value) => new Dictionary<string, object> { [name] = value };
        }

        private class DummyResponseHandler : IRemoteCallResponseResultHandler
        {
            public T Handle<T>(System.Net.HttpStatusCode statusCode, string body)
            {
                // return body as-is for testing when T is string
                if (typeof(T) == typeof(string))
                {
                    return (T)(object)body;
                }
                return default;
            }
        }

        [Fact]
        public async Task ValidateParameters_ResolveUrl_BeforeAfter_Log_Works()
        {
            var services = new ServiceCollection();
            services.AddSingleton<IRemoteCallParameterValidator>(new DummyValidator());
            services.AddSingleton<IRemoteCallUrlResolver>(new DummyUrlResolver());
            services.AddSingleton<IJsonSerializer>(new DummyJsonSerializer());
            services.AddSingleton<ICommonUtils>(new DummyCommonUtils());
            services.AddSingleton<IRemoteCallResponseResultHandler>(new DummyResponseHandler());
            // Register default concrete handler required by AfterResponseAsync when no ResponseResultAttribute is present
            services.AddSingleton<DefaultRemoteCallResponseResultHandler>();

            var provider = services.BuildServiceProvider();

            var interceptor = new TestInterceptor();
            interceptor.ServiceProvider = provider;

            var method = typeof(AbstractRequestInterceptor_TempHelper).GetMethod("SamplePost", BindingFlags.Public | BindingFlags.Static);

            var invocation = new FakeInvocation
            {
                ServiceProvider = provider,
                InterfaceType = typeof(AbstractRequestInterceptor_TempHelper),
                Method = method,
                ParameterInfos = method.GetParameters(),
                ParameterValues = new object[] { "raw=1&b=2" },
                WrapParameterValues = new List<Kurisu.RemoteCall.ParameterValue> { new Kurisu.RemoteCall.ParameterValue(method.GetParameters()[0], "raw=1&b=2") },
                RemoteClient = new RemoteClient { Name = "name", BaseUrl = "http://example.com" }
            };

            interceptor.ProxyInvocation = invocation;

            // ValidateParameters should not throw
            interceptor.ValidateParameters(invocation.ParameterValues);

            // ResolveUrl should combine
            var url = interceptor.ResolveUrl("GET", "http://api", "path", invocation.WrapParameterValues);
            Assert.Equal("http://api/path", url);

            // BeforeRequestAsync will set request.Content and _requestBody (via StringContent)
            var request = new HttpRequestMessage(System.Net.Http.HttpMethod.Post, url);
            await interceptor.BeforeRequestAsync(new HttpClient(), request);
            var content = await request.Content.ReadAsStringAsync();
            Assert.NotNull(content);

            // AfterResponseAsync should use DummyResponseHandler
            var response = new HttpResponseMessage(System.Net.HttpStatusCode.OK)
            {
                Content = new StringContent("{ \"ok\": true }", Encoding.UTF8, "application/json")
            };

            var result = await interceptor.AfterResponseAsync(response);
            Assert.Equal("{ \"ok\": true }", result);

            // Log should not throw
            var loggerFactory = provider.GetService<ILoggerFactory>() ?? LoggerFactory.Create(builder => builder.AddConsole());
            var logger = loggerFactory.CreateLogger("test");
            interceptor.Log(logger, "POST", url);
        }
    }

    public static class AbstractRequestInterceptor_TempHelper
    {
        public static string SamplePost(string body) => body;
    }
}
