// <auto-generated />

using System.Collections;
using System.Reflection;
using Kurisu.RemoteCall.Utils;
using Kurisu.RemoteCall.Abstractions;
using Kurisu.RemoteCall.Utils;
using Xunit;
using Newtonsoft.Json.Linq;

namespace Kurisu.Test.RemoteCall.UnitTests
{
    public class CommonUtils_GenericDict_Tests
    {
        private IJsonSerializer _serializer = new Kurisu.RemoteCall.Utils.NewtonsoftJsonSerializer();
        private CommonUtils Create() => new CommonUtils(_serializer);

        [Fact]
        public void ToObjDictionary_GenericDictionary_StringKeys_Works()
        {
            var utils = Create();
            var dict = new Dictionary<string, object>
            {
                ["a"] = 1,
                ["b"] = "x",
                ["c"] = new[] { 7, 8 }
            };

            var result = utils.ToObjDictionary("p", dict);

            // count may vary depending on internal flattening; ensure expected keys exist and have correct values
            Assert.True(result.Count >= 4);
            Assert.Equal(1, result["p.a"]);
            Assert.Equal("x", result["p.b"]);
            Assert.Equal(7, result["p.c[0]"]);
            Assert.Equal(8, result["p.c[1]"]);
        }

        [Fact]
        public void ToObjDictionary_GenericDictionary_NonStringKey_Works()
        {
            var utils = Create();
            var dict = new Dictionary<int, string>
            {
                [10] = "ten",
                [20] = "twenty"
            };

            var result = utils.ToObjDictionary(null, dict);

            Assert.Equal(2, result.Count);
            Assert.Equal("ten", result["10"]);
            Assert.Equal("twenty", result["20"]);
        }

        [Fact]
        public void ToObjDictionary_GenericDictionary_ComplexValue_UsesToObjDictionary()
        {
            var utils = Create();
            var dict = new Dictionary<string, object>
            {
                ["nested"] = new { X = 5, Y = "yy" }
            };

            var result = utils.ToObjDictionary("root", dict);

            Assert.Equal(2, result.Count);
            Assert.Equal(5L, result["root.nested.X"]);
            Assert.Equal("yy", result["root.nested.Y"]);
        }

        [Fact]
        public void CombineKey_PrivateMethod_BracketAndNullCases()
        {
            var mi = typeof(CommonUtils).GetMethod("CombineKey", BindingFlags.NonPublic | BindingFlags.Static);
            Assert.NotNull(mi);

            // prefix empty => returns key or empty
            var r1 = mi.Invoke(null, new object[] { string.Empty, (string)null });
            Assert.Equal(string.Empty, r1);

            // prefix non-empty and key starts with [ => concatenates without dot
            var r2 = mi.Invoke(null, new object[] { "p", "[0]" });
            Assert.Equal("p[0]", r2);

            // prefix non-empty and key normal => dot join
            var r3 = mi.Invoke(null, new object[] { "p", "name" });
            Assert.Equal("p.name", r3);

            // key empty => return prefix
            var r4 = mi.Invoke(null, new object[] { "prefix", string.Empty });
            Assert.Equal("prefix", r4);
        }

        [Fact]
        public void ToObjDictionary_GenericDict_StringValues_Works()
        {
            var dict = new Dictionary<string, string> { { "a", "1" }, { "b", "2" } };
            var utils = Create();
            var res = utils.ToObjDictionary("pref", dict);
            Assert.Equal("1", res["pref.a"].ToString());
            Assert.Equal("2", res["pref.b"].ToString());
        }

        [Fact]
        public void ToObjDictionary_GenericDict_ComplexValue_List_ProducesIndexedKeys()
        {
            var dict = new Dictionary<string, List<int>> { { "nums", new List<int> { 10, 20 } } };
            var utils = Create();
            var res = utils.ToObjDictionary("p", dict);
            Assert.Equal(10, (int)res["p.nums[0]"]!);
            Assert.Equal(20, (int)res["p.nums[1]"]!);
        }

        [Fact]
        public void ToObjDictionary_GenericDict_Empty_ReturnsEmpty()
        {
            var dict = new Dictionary<string, string>();
            var utils = Create();
            var res = utils.ToObjDictionary("x", dict);
            Assert.Empty(res);
        }

        private class NullKeyDictionary : IDictionary<string, string>
        {
            private readonly List<KeyValuePair<string, string>> _items = new();
            public NullKeyDictionary()
            {
                _items.Add(new KeyValuePair<string, string>(null, "nullval"));
            }

            public IEnumerator<KeyValuePair<string, string>> GetEnumerator() => _items.GetEnumerator();
            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => _items.GetEnumerator();
            public void Add(KeyValuePair<string, string> item) => _items.Add(item);
            public void Clear() => _items.Clear();
            public bool Contains(KeyValuePair<string, string> item) => _items.Contains(item);
            public void CopyTo(KeyValuePair<string, string>[] array, int arrayIndex) => _items.CopyTo(array, arrayIndex);
            public bool Remove(KeyValuePair<string, string> item) => _items.Remove(item);
            public int Count => _items.Count;
            public bool IsReadOnly => false;
            public void Add(string key, string value) => _items.Add(new KeyValuePair<string, string>(key, value));
            public bool ContainsKey(string key) => _items.Any(k => k.Key == key);
            public bool Remove(string key) { var idx = _items.FindIndex(k => k.Key == key); if (idx>=0) { _items.RemoveAt(idx); return true;} return false; }
            public bool TryGetValue(string key, out string value) { var kv = _items.FirstOrDefault(k => k.Key == key); value = kv.Value; return kv.Key != null; }
            public string this[string key] { get => _items.First(k => k.Key == key).Value; set { var idx = _items.FindIndex(k => k.Key == key); if (idx>=0) _items[idx] = new KeyValuePair<string,string>(key, value); else _items.Add(new KeyValuePair<string,string>(key, value)); } }
            public ICollection<string> Keys => _items.Select(k => k.Key).ToList();
            public ICollection<string> Values => _items.Select(k => k.Value).ToList();
        }

        [Fact]
        public void ToObjDictionary_GenericDict_NullKey_UsesPrefixKey()
        {
            var dict = new NullKeyDictionary();
            var utils = Create();
            var res = utils.ToObjDictionary("pref", dict);
            // when key is null, code treats key as empty and combined key = prefix
            Assert.True(res.ContainsKey("pref"));
            Assert.Equal("nullval", res["pref"].ToString());
        }

        [Fact]
        public void ToObjDictionary_GenericDict_NestedGenericDictValue_Works()
        {
            var inner = new Dictionary<string, int> { ["a"] = 1 };
            var dict = new Dictionary<string, object> { ["outer"] = inner };
            var utils = Create();
            var res = utils.ToObjDictionary("p", dict);
            Assert.Equal(1, (int)res["p.outer.a"]!);
        }

        private class NonStandardEnumeratorDict : IDictionary<string, object>
        {
            private readonly List<KeyValuePair<string, object>> _inner = new();
            public NonStandardEnumeratorDict()
            {
                _inner.Add(new KeyValuePair<string, object>("k1", new List<int> { 1 }));
            }

            // This type will be returned by the non-generic enumerator (no Key property)
            public class WeirdKvp
            {
                public object Value { get; }
                public WeirdKvp(object value) => Value = value;
            }

            // Return a non-generic enumerator that yields WeirdKvp objects
            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
            {
                foreach (var kv in _inner)
                {
                    yield return new WeirdKvp(kv.Value);
                }
            }

            // Generic enumerator still returns real KeyValuePair (not used by the target method since it casts to non-generic IEnumerable)
            public IEnumerator<KeyValuePair<string, object>> GetEnumerator() => _inner.GetEnumerator();

            // Minimal IDictionary implementation
            public void Add(KeyValuePair<string, object> item) => _inner.Add(item);
            public void Clear() => _inner.Clear();
            public bool Contains(KeyValuePair<string, object> item) => _inner.Contains(item);
            public void CopyTo(KeyValuePair<string, object>[] array, int arrayIndex) => _inner.CopyTo(array, arrayIndex);
            public bool Remove(KeyValuePair<string, object> item) => _inner.Remove(item);
            public int Count => _inner.Count;
            public bool IsReadOnly => false;
            public void Add(string key, object value) => _inner.Add(new KeyValuePair<string, object>(key, value));
            public bool ContainsKey(string key) => _inner.Exists(k => k.Key == key);
            public bool Remove(string key) { var idx = _inner.FindIndex(k => k.Key == key); if (idx>=0) { _inner.RemoveAt(idx); return true; } return false; }
            public bool TryGetValue(string key, out object value) { var kv = _inner.Find(k => k.Key == key); if (kv.Key != null) { value = kv.Value; return true; } value = null; return false; }
            public object this[string key] { get => _inner.First(k => k.Key == key).Value; set { var idx = _inner.FindIndex(k => k.Key == key); if (idx>=0) _inner[idx] = new KeyValuePair<string, object>(key, value); else _inner.Add(new KeyValuePair<string, object>(key, value)); } }
            public ICollection<string> Keys => _inner.Select(k => k.Key).ToList();
            public ICollection<object> Values => _inner.Select(k => k.Value).ToList();
        }

        [Fact]
        public void ToObjDictionary_GenericDict_WithNonStandardEnumerator_HandlesMissingKeyProperty()
        {
            var dict = new NonStandardEnumeratorDict();
            var utils = Create();
            var res = utils.ToObjDictionary("pref", dict);
            // The custom enumerator yields an element with no Key; combinedKey should be prefix
            Assert.True(res.ContainsKey("pref[0]") || res.ContainsKey("pref"));
        }

        [Fact]
        public void ToObjDictionary_JArray_Empty_SetsPrefixToNull()
        {
            var jArray = new Newtonsoft.Json.Linq.JArray();
            var utils = Create();
            var res = utils.ToObjDictionary("p", jArray);
            Assert.True(res.ContainsKey("p"));
            Assert.Null(res["p"]);
        }
    }
}
