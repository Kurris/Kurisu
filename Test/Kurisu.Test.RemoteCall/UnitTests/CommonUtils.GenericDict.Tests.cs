// <auto-generated />
using System.Reflection;
using Kurisu.RemoteCall.Utils;
using Kurisu.RemoteCall.Abstractions;
using Kurisu.RemoteCall.Utils;
using Xunit;
using Newtonsoft.Json.Linq;

namespace Kurisu.Test.RemoteCall.UnitTests
{
    public class CommonUtils_GenericDict_Tests
    {
        private IJsonSerializer _serializer = new Kurisu.RemoteCall.Utils.NewtonsoftJsonSerializer();
        private CommonUtils Create() => new CommonUtils(_serializer);

        [Fact]
        public void ToObjDictionary_GenericDictionary_StringKeys_Works()
        {
            var utils = Create();
            var dict = new Dictionary<string, object>
            {
                ["a"] = 1,
                ["b"] = "x",
                ["c"] = new[] { 7, 8 }
            };

            var result = utils.ToObjDictionary("p", dict);

            // count may vary depending on internal flattening; ensure expected keys exist and have correct values
            Assert.True(result.Count >= 4);
            Assert.Equal(1, result["p.a"]);
            Assert.Equal("x", result["p.b"]);
            Assert.Equal(7, result["p.c[0]"]);
            Assert.Equal(8, result["p.c[1]"]);
        }

        [Fact]
        public void ToObjDictionary_GenericDictionary_NonStringKey_Works()
        {
            var utils = Create();
            var dict = new Dictionary<int, string>
            {
                [10] = "ten",
                [20] = "twenty"
            };

            var result = utils.ToObjDictionary(null, dict);

            Assert.Equal(2, result.Count);
            Assert.Equal("ten", result["10"]);
            Assert.Equal("twenty", result["20"]);
        }

        [Fact]
        public void ToObjDictionary_GenericDictionary_ComplexValue_UsesToObjDictionary()
        {
            var utils = Create();
            var dict = new Dictionary<string, object>
            {
                ["nested"] = new { X = 5, Y = "yy" }
            };

            var result = utils.ToObjDictionary("root", dict);

            Assert.Equal(2, result.Count);
            Assert.Equal(5L, result["root.nested.X"]);
            Assert.Equal("yy", result["root.nested.Y"]);
        }

        [Fact]
        public void CombineKey_PrivateMethod_BracketAndNullCases()
        {
            var mi = typeof(CommonUtils).GetMethod("CombineKey", BindingFlags.NonPublic | BindingFlags.Static);
            Assert.NotNull(mi);

            // prefix empty => returns key or empty
            var r1 = mi.Invoke(null, new object[] { string.Empty, (string)null });
            Assert.Equal(string.Empty, r1);

            // prefix non-empty and key starts with [ => concatenates without dot
            var r2 = mi.Invoke(null, new object[] { "p", "[0]" });
            Assert.Equal("p[0]", r2);

            // prefix non-empty and key normal => dot join
            var r3 = mi.Invoke(null, new object[] { "p", "name" });
            Assert.Equal("p.name", r3);

            // key empty => return prefix
            var r4 = mi.Invoke(null, new object[] { "prefix", string.Empty });
            Assert.Equal("prefix", r4);
        }
    }
}
