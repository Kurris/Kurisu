// <auto-generated />
using System.Reflection;
using Kurisu.RemoteCall;
using Kurisu.RemoteCall.Default;
using Kurisu.RemoteCall.Proxy.Abstractions;
using Microsoft.Extensions.Logging;
using Xunit;

namespace Kurisu.Test.RemoteCall.UnitTests
{
    public class BaseRemoteCallClient_Tests
    {
        private class MinimalInvocation : IProxyInvocation
        {
            public IServiceProvider ServiceProvider { get; set; }
            public Type InterfaceType { get; set; }
            public MethodInfo Method { get; set; }
            public ParameterInfo[] ParameterInfos { get; set; }
            public object[] ParameterValues { get; set; }
            public List<Kurisu.RemoteCall.ParameterValue> WrapParameterValues { get; set; }
            public object ReturnValue { get; set; }
            public RemoteClient RemoteClient { get; set; }
        }

        private class TestClient : BaseRemoteCallClient
        {
            private readonly Func<IProxyInvocation, Task<object>> _impl;

            public TestClient(ILogger logger, Func<IProxyInvocation, Task<object>> impl) : base(logger)
            {
                _impl = impl;
            }

            public override string RequestType => "Test";

            protected override Task<TResult> RequestAsync<TResult>(IProxyInvocation invocation)
            {
                // delegate to provided func and cast; await to avoid AggregateException wrapping
                return _impl(invocation).ContinueWith(tsk =>
                {
                    // propagate original exception types
                    if (tsk.IsFaulted) return Task.FromException<TResult>(tsk.Exception!.InnerException ?? tsk.Exception!);
                    if (tsk.IsCanceled) return Task.FromCanceled<TResult>(new CancellationToken(true));
                    return Task.FromResult((TResult)tsk.Result);
                }).Unwrap();
            }

            // expose the protected HandleAsync for testing
            public Task InvokeHandleAsync(IProxyInvocation invocation) => base.HandleAsync(invocation);
        }

        [Fact]
        public async Task HandleAsync_Completes_CallsRequestAsync()
        {
            var called = false;
            var logger = new LoggerFactory().CreateLogger("test");
            var client = new TestClient(logger, inv => {
                called = true;
                return Task.FromResult<object>(new object());
            });

            var invoc = new MinimalInvocation();

            await client.InvokeHandleAsync(invoc);

            Assert.True(called);
        }

        [Fact]
        public async Task HandleAsync_RequestAsyncThrows_PropagatesException()
        {
            var logger = new LoggerFactory().CreateLogger("test");
            var client = new TestClient(logger, inv => Task.FromException<object>(new InvalidOperationException("boom")));
            var invoc = new MinimalInvocation();

            await Assert.ThrowsAsync<InvalidOperationException>(() => client.InvokeHandleAsync(invoc));
        }
    }
}
