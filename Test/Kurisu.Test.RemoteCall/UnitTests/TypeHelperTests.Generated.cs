// <auto-generated />
using System;
using System.Collections;
using System.Collections.Generic;
using Kurisu.RemoteCall.Utils;
using Xunit;

namespace Kurisu.Test.RemoteCall.UnitTests;

public class TypeHelperTests
{
    private struct MyStruct { public int X; public string Y; }

    [Fact]
    public void IsSimpleType_PrimitiveAndSpecials()
    {
        Assert.True(TypeHelper.IsSimpleType(typeof(int)));
        Assert.True(TypeHelper.IsSimpleType(typeof(string)));
        Assert.True(TypeHelper.IsSimpleType(typeof(decimal)));
        Assert.True(TypeHelper.IsSimpleType(typeof(DateTime)));
        Assert.True(TypeHelper.IsSimpleType(typeof(DateTimeOffset)));
        Assert.True(TypeHelper.IsSimpleType(typeof(TimeSpan)));
        Assert.True(TypeHelper.IsSimpleType(typeof(Guid)));
        Assert.True(TypeHelper.IsSimpleType(typeof(Uri)));
        Assert.True(TypeHelper.IsSimpleType(typeof(byte[])));
        Assert.False(TypeHelper.IsSimpleType(typeof(object)));
        Assert.False(TypeHelper.IsSimpleType(typeof(List<int>)));
        // Nullable underlying type should be considered simple
        Assert.True(TypeHelper.IsSimpleType(typeof(int?)));
    }

    [Fact]
    public void IsEnumerable_DetectsArrayAndGeneric()
    {
        Assert.True(TypeHelper.IsEnumerable(typeof(int[]), out var et1));
        Assert.Equal(typeof(int), et1);

        Assert.True(TypeHelper.IsEnumerable(typeof(List<string>), out var et2));
        Assert.Equal(typeof(string), et2);

        Assert.False(TypeHelper.IsEnumerable(typeof(string), out _));
    }

    [Fact]
    public void IsEnumerableOfSimple_Works()
    {
        Assert.True(TypeHelper.IsEnumerableOfSimple(typeof(List<int>)));
        Assert.False(TypeHelper.IsEnumerableOfSimple(typeof(List<object>)));
    }

    [Fact]
    public void IsDictionary_DetectsGenericAndNonGeneric()
    {
        Assert.True(TypeHelper.IsDictionary(typeof(Dictionary<string, int>), out var key, out var val));
        Assert.Equal(typeof(string), key);
        Assert.Equal(typeof(int), val);

        Assert.True(TypeHelper.IsDictionary(typeof(Hashtable), out key, out val));
        Assert.Equal(typeof(object), key);
        Assert.Equal(typeof(object), val);

        Assert.False(TypeHelper.IsDictionary(typeof(List<int>), out _, out _));
    }

    [Fact]
    public void IsComplexType_IdentifiesComplexsAndExcludesSimpleOrCollections()
    {
        Assert.False(TypeHelper.IsComplexType(typeof(int)));
        Assert.False(TypeHelper.IsComplexType(typeof(string)));
        Assert.True(TypeHelper.IsComplexType(typeof(List<int>)));
        Assert.True(TypeHelper.IsComplexType(typeof(Dictionary<string, string>)));

        Assert.True(TypeHelper.IsComplexType(typeof(MyStruct)));

        // class
        Assert.True(TypeHelper.IsComplexType(typeof(Exception)));
    }

    [Fact]
    public void IsReferenceType_WorksForVariousTypes()
    {
        Assert.True(TypeHelper.IsReferenceType(typeof(string)) == false); // string is explicitly excluded
        Assert.True(TypeHelper.IsReferenceType(typeof(object)));
        Assert.True(TypeHelper.IsReferenceType(typeof(IEnumerable<int>)));
        Assert.False(TypeHelper.IsReferenceType(typeof(int)));
        Assert.False(TypeHelper.IsReferenceType(null));
    }
}
