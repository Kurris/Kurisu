// <auto-generated />
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
using System.Reflection;
using Kurisu.RemoteCall;
using Kurisu.RemoteCall.Abstractions;
using Kurisu.RemoteCall.Attributes;
using Kurisu.RemoteCall.Default;
using Kurisu.RemoteCall.Proxy.Abstractions;
using Kurisu.RemoteCall.Utils;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Xunit;

namespace Kurisu.Test.RemoteCall.UnitTests
{
    public class HttpClientRemoteCallClient_ExceptionHandling_Tests
    {
        // simple HttpMessageHandler that throws on SendAsync
        private class ThrowingHandler : HttpMessageHandler
        {
            protected override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
            {
                throw new InvalidOperationException("send-failure");
            }
        }

        // simple HttpMessageHandler that returns OK with body
        private class OkHandler : HttpMessageHandler
        {
            private readonly string _body;
            public OkHandler(string body) { _body = body; }
            protected override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
            {
                var resp = new HttpResponseMessage(HttpStatusCode.OK)
                {
                    Content = new StringContent(_body)
                };
                return Task.FromResult(resp);
            }
        }

        [AttributeUsage(AttributeTargets.Method)]
        private class TestRequestInterceptorAttribute : Kurisu.RemoteCall.Attributes.AbstractRequestInterceptorAttribute<string>
        {
            public override Task BeforeRequestAsync(HttpClient httpClient, HttpRequestMessage request)
            {
                throw new Exception("before-throw");
            }

            public override bool TryOnException(Exception exception, out string result)
            {
                result = "handled";
                return true;
            }

            public override Task<string> AfterResponseAsync(HttpResponseMessage response)
            {
                return Task.FromResult("after");
            }

            public override void ValidateParameters(object[] parameters) { }
            public override string ResolveUrl(string httpMethod, string baseUrl, string template, List<ParameterValue> wrapParameterValues) => "http://localhost/api/test";
        }

        public interface ITestApi
        {
            [Get("api/test")]
            [TestRequestInterceptor]
            Task<string> PingAsync();
        }

        public interface ITestApiNoHandle
        {
            [Get("api/test")]
            Task<string> PingAsync();
        }

        private IServiceProvider BuildServices(HttpMessageHandler handler)
        {
            var services = new ServiceCollection();
            services.AddSingleton<IJsonSerializer, Kurisu.RemoteCall.Utils.NewtonsoftJsonSerializer>();
            services.AddSingleton<ICommonUtils, CommonUtils>();
            services.AddSingleton<IRemoteCallParameterValidator, Kurisu.RemoteCall.Default.DefaultParameterValidator>();
            services.AddSingleton<IRemoteCallUrlResolver, Kurisu.RemoteCall.Default.DefaultRemoteCallUrlResolver>();
            services.AddSingleton<DefaultRemoteCallResponseResultHandler>();
            // HttpClientFactory
            var client = new HttpClient(handler) { BaseAddress = new Uri("http://localhost") };
            services.AddSingleton<IHttpClientFactory>(sp => new SimpleFactory(client));
            services.AddLogging();
            return services.BuildServiceProvider();
        }

        private class SimpleFactory : IHttpClientFactory
        {
            private readonly HttpClient _client;
            public SimpleFactory(HttpClient client) => _client = client;
            public HttpClient CreateClient(string name) => _client;
            public HttpClient CreateClient() => _client;
        }

        // expose protected RequestAsync for testing by deriving and adding a public wrapper
        private class TestHttpClientRemoteCallClient : Kurisu.RemoteCall.HttpClientRemoteCallClient
        {
            public TestHttpClientRemoteCallClient(IHttpClientFactory httpClientFactory, ILogger<Kurisu.RemoteCall.HttpClientRemoteCallClient> logger)
                : base(httpClientFactory, logger)
            {
            }

            public Task<TResult> PublicRequestAsync<TResult>(IProxyInvocation invocation)
            {
                return base.RequestAsync<TResult>(invocation);
            }
        }

        [Fact]
        public async Task RequestAsync_InterceptorHandlesException_ReturnsHandledResult()
        {
            var sp = BuildServices(new OkHandler("{}"));
            var factory = sp.GetRequiredService<IHttpClientFactory>();
            var logger = sp.GetRequiredService<ILogger<HttpClientRemoteCallClient>>();
            var client = new TestHttpClientRemoteCallClient(factory, logger);

            var method = typeof(ITestApi).GetMethod(nameof(ITestApi.PingAsync));
            var inv = new MinimalInvocation
            {
                Method = method,
                InterfaceType = typeof(ITestApi),
                ParameterInfos = method.GetParameters(),
                ParameterValues = new object[0],
                WrapParameterValues = new List<ParameterValue>(),
                RemoteClient = new RemoteClient { Name = string.Empty, BaseUrl = "http://localhost" },
                ServiceProvider = sp
            };

            var result = await client.PublicRequestAsync<string>(inv);
            Assert.Equal("handled", result);
        }

        [Fact]
        public async Task RequestAsync_HttpClientThrows_PropagatesException_WhenInterceptorDoesNotHandle()
        {
            var sp = BuildServices(new ThrowingHandler());
            var factory = sp.GetRequiredService<IHttpClientFactory>();
            var logger = sp.GetRequiredService<ILogger<HttpClientRemoteCallClient>>();
            var client = new TestHttpClientRemoteCallClient(factory, logger);

            var method = typeof(ITestApiNoHandle).GetMethod(nameof(ITestApiNoHandle.PingAsync));
            var inv = new MinimalInvocation
            {
                Method = method,
                InterfaceType = typeof(ITestApiNoHandle),
                ParameterInfos = method.GetParameters(),
                ParameterValues = new object[0],
                WrapParameterValues = new List<ParameterValue>(),
                RemoteClient = new RemoteClient { Name = string.Empty, BaseUrl = "http://localhost" },
                ServiceProvider = sp
            };

            await Assert.ThrowsAsync<InvalidOperationException>(() => client.PublicRequestAsync<string>(inv));
        }

        // reuse MinimalInvocation from other tests
        private class MinimalInvocation : IProxyInvocation
        {
            public IServiceProvider ServiceProvider { get; set; }
            public Type InterfaceType { get; set; }
            public MethodInfo Method { get; set; }
            public ParameterInfo[] ParameterInfos { get; set; }
            public object[] ParameterValues { get; set; }
            public List<ParameterValue> WrapParameterValues { get; set; }
            public object ReturnValue { get; set; }
            public RemoteClient RemoteClient { get; set; }
        }
    }
}
