// <auto-generated />
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Microsoft.Extensions.Configuration;
using Kurisu.RemoteCall.Default;
using Kurisu.RemoteCall;
using Xunit;

namespace Kurisu.Test.RemoteCall.UnitTests
{
    public class DefaultRemoteCallUrlResolver_Tests
    {
        // helper method to get ParameterInfo[] from a dummy method
        private static ParameterInfo[] GetParameterInfos(params Type[] types)
        {
            var dm = typeof(DefaultRemoteCallUrlResolver_Tests).GetMethod(nameof(DummyMethod), BindingFlags.NonPublic | BindingFlags.Static)!
                .MakeGenericMethod(types.Length == 0 ? new Type[] { typeof(object) } : new Type[] { typeof(object) });
            // instead of generating dynamic generic method, just reflect a known method
            return typeof(DefaultRemoteCallUrlResolver_Tests).GetMethod(nameof(DummyMethod2), BindingFlags.NonPublic | BindingFlags.Static)!.GetParameters();
        }

        private static void DummyMethod<T>() { }

        private static void DummyMethod2(int id, string name, object obj) { }

        [Fact]
        public void ResolvePostUrl_ReplacesSimplePlaceholders()
        {
            // Use reflection to call private static ResolvePostUrl on DefaultRemoteCallUrlResolver
            var asm = typeof(BaseRemoteCallUrlResolver).Assembly;
            var t = asm.GetType("Kurisu.RemoteCall.Default.DefaultRemoteCallUrlResolver", throwOnError: true);
            var mi = t.GetMethod("ResolvePostUrl", BindingFlags.NonPublic | BindingFlags.Static);
            Assert.NotNull(mi);

            // Get ParameterInfo for DummyMethod2's parameters
            var pInfos = typeof(DefaultRemoteCallUrlResolver_Tests).GetMethod(nameof(DummyMethod2), BindingFlags.NonPublic | BindingFlags.Static)!.GetParameters();
            var list = new List<ParameterValue>
            {
                new ParameterValue(pInfos[0], 123),
                new ParameterValue(pInfos[1], "a b")
            };

            var template = "api/{id}/items/{name}";
            var result = (string)mi.Invoke(null, new object[] { template, list });

            Assert.Contains("123", result);
            Assert.Contains("a+b", result); // name should be url-encoded (space => '+')
        }

        [Fact]
        public void ResolvePostUrl_DoesNotReplaceForClassTypes()
        {
            var asm = typeof(BaseRemoteCallUrlResolver).Assembly;
            var t = asm.GetType("Kurisu.RemoteCall.Default.DefaultRemoteCallUrlResolver", throwOnError: true);
            var mi = t.GetMethod("ResolvePostUrl", BindingFlags.NonPublic | BindingFlags.Static);
            Assert.NotNull(mi);

            var pInfos = typeof(DefaultRemoteCallUrlResolver_Tests).GetMethod(nameof(DummyMethod2), BindingFlags.NonPublic | BindingFlags.Static)!.GetParameters();
            // use the third parameter which is object (class)
            var list = new List<ParameterValue>
            {
                new ParameterValue(pInfos[2], "shouldNotReplace")
            };

            var template = "api/{obj}/value";
            var result = (string)mi.Invoke(null, new object[] { template, list });

            // object parameter is a class, so the placeholder should remain
            Assert.Equal(template, result);
        }

        [Fact]
        public void FixFromConfiguration_ReplacesPlaceholdersFromConfig()
        {
            // create in-memory configuration
            var cfg = new ConfigurationBuilder().AddInMemoryCollection(new Dictionary<string, string>
            {
                ["Service:Url"] = "https://api.example.com",
                ["Key"] = "VALUE"
            }).Build();

            // create a test subclass to expose ResolveBaseUrl
            var resolver = new TestResolver(cfg);

            var input = "http://${Service:Url}/path/${Key}";
            var output = resolver.PublicResolveBaseUrl(input);

            Assert.DoesNotContain("${", output);
            Assert.Contains("https://api.example.com", output);
            Assert.Contains("VALUE", output);
        }

        private class TestResolver : BaseRemoteCallUrlResolver
        {
            public TestResolver(IConfiguration cfg) : base(cfg) { }
            public string PublicResolveBaseUrl(string s) => base.ResolveBaseUrl(s);
        }
    }
}
